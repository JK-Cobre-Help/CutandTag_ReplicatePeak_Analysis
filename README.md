# CutandTag_ReplicatePeak_Analysis

![ReplicatePeaks](/images/replicatePeaks.png)
+ OpenAI. (2024). Scientific data visualization: Replicate peak analysis in bioinformatics [AI-generated image]. DALL-E. Retrieved from ChatGPT interface.

# 1) Project Description
CutAndTag_ReplicatePeak_Analysis is a Snakemake pipeline designed to perform downstream peak analysis on processed Cut-and-Tag sequencing data. Rather than starting from raw FASTQ reads, this pipeline starts with already aligned and filtered BAM files, focusing on the identification of reproducible peaks, the generation of consensus peak sets, and the visualization of overlaps and signal distributions across multiple samples or experimental conditions.

+ Note: If you are starting from raw FASTQ files, consider using the [CutandTag_Analysis_Snakemake](https://github.com/JK-Cobre-Help/CutandTag_Analysis_Snakemake) pipeline first. That pipeline handles the initial data processing steps—such as quality control, alignment, and basic filtering—providing you with the cleaned and aligned data that serve as the input for CutAndTag_ReplicatePeak_Analysis.

## Key Features
+ Peak Calling with MACS2:
    + The pipeline calls peaks for each sample using MACS2, a widely-used tool for identifying enriched regions in ChIP- or Cut-and-Tag sequencing data.

+ Merged and Consensus Peak Sets:
    + Using sample groupings defined in samples.csv (particularly the "Set" column), peaks are merged to produce a comprehensive candidate region set. A consensus peak set is then generated by applying a reproducibility threshold, ensuring that only peaks observed in a configurable minimum number of samples are retained.

+ Consensus Peak Conversion:
    + Consensus peak sets are converted into BAM and BigWig formats, enabling efficient genome browser visualization and facilitating downstream analyses.

Euler Plots of Overlaps:
The pipeline creates Euler diagrams to represent the overlap of peaks among individual samples within a set. This visual approach reveals how consensus peaks emerge from the intersection of multiple replicates.

Midpoint and Overlap Analysis:
The pipeline identifies peak midpoints and quantifies overlaps, enabling a more granular exploration of peak distribution and subtle differences or similarities across samples.

Heatmaps for Signal Distribution:
By using consensus peak midpoints, the pipeline generates heatmaps that visualize aggregated signal (coverage) patterns. These heatmaps provide insights into the intensity and distribution of signal across multiple conditions or sample sets.

Intended Use Case
This pipeline is ideal for researchers who have already processed their Cut-and-Tag data through preliminary steps such as quality control, trimming, alignment, and filtering (e.g., by using CutandTag_Analysis_Snakemake). After obtaining high-quality aligned BAM files, you can use CutAndTag_ReplicatePeak_Analysis to:

Identify reproducible peaks across replicates or experimental conditions.
Generate integrative visual summaries of peak overlaps.
Compare signal intensity profiles around consensus peak midpoints.
By integrating this two-step approach, you ensure a robust, end-to-end workflow for your Cut-and-Tag sequencing experiments.
# 2) Instructions to run on Slurm managed HPC
2A. Clone repository
```
git clone https://github.com/JK-Cobre-Help/CutandTag_ReplicatePeak_Analysis.git
```
2B. Load modules
```
module purge
module load slurm python/3.10 pandas/2.2.3 numpy/1.22.3 matplotlib/3.7.1
```
2C. Modify samples and config file
```
vim samples.csv
vim config.yml
```
2D. Dry Run
```
snakemake -npr
```
2E. Run on HPC with config.yml options
```
sbatch --wrap="snakemake -j 999 --use-envmodules --latency-wait 60 --cluster-config config/cluster_config.yml --cluster 'sbatch -A {cluster.account} -p {cluster.partition} --cpus-per-task {cluster.cpus-per-task}  -t {cluster.time} --mem {cluster.mem} --output {cluster.output}'"
```

# 3) Explanation of samples.csv
Note. Make sure to check sample.csv before each run

The samples.csv file in the config folder has paths to the test fastq files. You must replace those paths with those for your own fastq files. The first column of each row is the sample name. This name will be used for all output files. Columns 2 and 3 are the paths to the paired fastq files. Column 4 is the sample type (either "treatment" or "control"). Column 5 is the name of the corresponding Control sample for each treated sample (use "NA" if the sample is a control).

| sample             | fastq1                        | fastq2                        | sampleType | Control   |
|--------------------|-------------------------------|-------------------------------|------------|-----------|
| K27ac_50_trimmed   | K27ac_50_trimmed_R1.fastq.gz  | K27ac_50_trimmed_R2.fastq.gz  | control    | NA        |
| K27me3_50_trimmed  | K27me3_50_trimmed_R1.fastq.gz | K27me3_50_trimmed_R1.fastq.gz | control    | NA        |


Sample naming recommendation for correct plot output
- "Histone" + "_" + "Replicate" + "Any other identifier"
- Examples:
    + K27ac_50
    + K27me3_5
    + K27ac_50_trimmed
    + H3K27me3_rep1
    + H3K4me3_rep2_set1
    + H3K27ac_rep3_control
    + H3K27ac_rep3_treatment

# 4) Explanation of config.yml
Note. Make sure to check config.yml for the appropriate genome alignment

The config.yml is used to identify the file path of the bowtie2 genome index, specify effective genome size and genome for macs2. There is also information about specific modules and version numbers to maintain dependencies in the snakemake workflow. Running the mm10 genome does not require any modifications to the config.yml. When using the hg38 genome the following need to be modified with the information provided in the config.yml but commented out.

Run hg38 samples in snakemake pipeline
- config.yml 
    + change bowtie2 genome index file path
    + change bamCoverage effective genome size
    + change macs2 genome size

# 5) Citations
Zheng, Y., Ahmad, K., & Henikoff, S. (2019). CUT&Tag for efficient epigenomic profiling of small samples and single cells. Protocols.io, dx.doi.org/10.17504/protocols.io.bjk2kkye
